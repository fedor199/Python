# Задание 1
# Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках домашнего задания первых
# трех уроков.
# Анализируется задача № 8 из домашнего задания № 2.
# Посчитать, сколько раз встречается определенная цифра в введенной последовательности чисел.
# Количество вводимых чисел и цифра, которую необходимо посчитать, задаются вводом с клавиатуры.
# Для исключения из анализа функций ввода оценивается только функция подсчета определенной цифры, встречающейся в числе.
# Числа с  большим количеством разрядов для оценки времени выполнения алгоритма.

import cProfile
RAZ = 10


# 1. Рекурсия, мой вариант домашнего задания
def count(dig, cf):
    dig1 = dig % RAZ
    if dig == 0:
        return 0
    if dig1 == cf:
        return 1 + count(dig // RAZ, cf)
    else:
        return count(dig // RAZ, cf)

# 100 loops, best of 3: 287 usec per loop - 2**1000 (302-х разрядное число)
# 100 loops, best of 3: 865 usec per loop - 2**2000 (603-х разрядное число)
# 100 loops, best of 3: 1.84 msec per loop - 2**3000 (904-х разрядное число)

# cProfile.run('count(2**1000,4)')
# 303/1    0.001    0.000    0.001    0.001 task_4.py:8(count) - 2**1000 (302-х разрядное число)
# 604/1    0.001    0.000    0.001    0.001 task_4.py:8(count) - 2**2000 (603-х разрядное число)
# 905/1    0.002    0.000    0.002    0.002 task_4.py:8(count) - 2**3000 (904-х разрядное число)


# 2. Цикл
def cycle_count(dig, cf):
    sm = 0
    while True:
        if dig % RAZ == cf:
            sm += 1
        dig = dig // RAZ
        if dig == 0:
            break
    return sm

# 100 loops, best of 3: 233 usec per loop - 2**1000 (302-х разрядное число)
# 100 loops, best of 3: 750 usec per loop - 2**2000 (603-х разрядное число)
# 100 loops, best of 3: 1.58 msec per loop - 2**3000 (904-х разрядное число)

# cProfile.run('cycle_count(2**3000,4)')
# 1    0.000    0.000    0.000    0.000 task_4.py:42(cycle_count) - 2**1000 (302-х разрядное число)
#  1    0.001    0.001    0.001    0.001 task_4.py:42(cycle_count) - 2**2000 (603-х разрядное число)
# 1    0.002    0.002    0.002    0.002 task_4.py:42(cycle_count) - 2**3000 (904-х разрядное число)


# 3. Цикл с предварительным преобразованием числа в список одноразрядных чисел
def cycle_count_lst(dig, cf):
    sm = 0
    array = [int(x) for x in str(dig)]
    for item in array:
        if item == cf:
            sm += 1
    return sm


# 100 loops, best of 3: 128 usec per loop - 2**1000 (302-х разрядное число)
# 100 loops, best of 3: 271 usec per loop - 2**2000 (603-х разрядное число)
# 100 loops, best of 3: 415 usec per loop - 2**3000 (904-х разрядное число)

# cProfile.run('cycle_count_lst (2**3000,4)')
# 1    0.000    0.000    0.000    0.000 task_4.py:62(cycle_count_lst) - 2**1000 (302-х разрядное число)
# 1    0.000    0.000    0.000    0.000 task_4.py:62(cycle_count_lst) - 2**2000 (603-х разрядное число)
# 1    0.000    0.000    0.000    0.000 task_4.py:62(cycle_count_lst) - 2**3000 (904-х разрядное число)


# 4. Преобразование числа в список одноразрядных чисел и использование встроенной функции count
def count_func(dig, cf):
    return [int(x) for x in str(dig)].count(cf)

# 100 loops, best of 3: 141 usec per loop - 2**1000 (302-х разрядное число)
# 100 loops, best of 3: 285 usec per loop - 2**2000 (603-х разрядное число)
# 100 loops, best of 3: 424 usec per loop - 2**3000 (904-х разрядное число)

# cProfile.run('count_func (2**3000,4)')
# 1    0.000    0.000    0.000    0.000 task_4.py:85(count_func) - 2**1000 (302-х разрядное число)
# 1    0.000    0.000    0.000    0.000 task_4.py:85(count_func) - 2**2000 (603-х разрядное число)
# 1    0.000    0.000    0.000    0.000 task_4.py:85(count_func) - 2**3000 (904-х разрядное число)

# Выводы.
# Мой вариант реализации функции с использованием рекурсивии обладает в среднем сложностью O(n * log n), также мой
# вариант оказался самым медленным по времени выполнения. Примерно аналогично работает вариант №2 реализации функции
# с использованием цикла с аналогичной сложностью O(n * log n). Быстрее работают функции по варианту № 3 и 4
# с предварительным преобразованием числа в список  одноразрядных чисел и дальнейшим поиском цифры в списке чисел,
# временная сложность данных алгоритмов в среднем O(n). Самый быстрый вариант по времени выполнения оказался
# вариант № 4  с использованием встроенной функции count.


# Не анализируемая функция.
def main():
    cnt = int(input('Введите количество вводимых чисел: '))
    cf = int(input('Введите цифру: '))
    sm = 0
    for i in range(cnt):
        dig = int(input('Введите число: '))
        sm += count(dig, cf)
    print(f'Цифра {cf} встречается {sm} раза')